<start>
<?php

/*unset( $_GET );

if(!isset($_SESSION) ||
    empty($_SESSION) ||
    session_status() == PHP_SESSION_NONE ||
    session_id() == '') die();

    if (strtoupper($_SERVER['REQUEST_METHOD']) === 'GET') die();*/

?>

<div>
  <img style="vertical-align:middle" src="../help/icon.png">
  <span style="font-size: 30px"><b>&nbsp;Documentation</b></span>
</div>

<center><h1>Welcome To Esketit</h1></center>
<p style="color: purple; text-align: center">Esketit is pronounced ssketit, don't think about it, sshkedit.</p>
<p>Decentralized peer to peer work environments, like functional co-opts run by AI were too hard to programme, so we made this instead. If you are like us, we want to completely immerse ourselves in crypto and leave the world behind. EsektitOS is a way to do this, supply users with complete immersion into the world of cryptocurrencies through esketitOS.</p>

<p>EsketitOS brings two features to the conventional wallet application, they are...</p>

<p>1) Enterprise management system.<br />
   2) Token store, for industry specific extensions and any application that extends the function of the wallet.<br />
</p>

<p>EsektitOS is not an account with a third party, it runs totally off your computer. When you turn your computer off, the account is no longer accessible, both locally or globally, over Internet. Through the allocation of wallets a network can be formed. These wallets are programmable, you can set them to send or receive at a variable time each day, week or time, they can send a specific amount each week only, they can restricted to send only. EsketitOS utilizes HTTP for network access, which is great if you have geographical dispersed branches or employees. The enterprise management software makes this appear seamless. Here is a diagram...</p>

<p><b>Allocate your wallets, review system metrics, do nothing or take actions...</b></p>

			<center><img src="../help/images/fig1.png" style="width: 50%"></center>

<p>The blockchain stores transaction records, flow of funds. Their are blockchain that store information as well and their are oracle services. Informational blockchains can holds operational data, such as the tracking numbers for a postal service or the location of supplies in transit. Even how many times a product was returned or required repairs. The software puts these metrics in one of these blockchains and collates these metrics out of the blockchain. They are stored forever and globally accessible to anyone, that is the rule. EsketitOS is not coin or token specific. This is software, an interface and if a blockchain holds some advance, we probably can utilize it and incorperate it.</p>

<p>Operation of the enterprise begins with the allocation of a wallet, and performance is gauged by the metrics of that wallet.</p>

<p><b><u>What About Receiving Payments From Customers</u></b></p>

<p>This is where the token store is required. The token store allows for the plugin of industry specific extensions. Software can overlay esketitOS so that it provides the management specific of a business such as point of sale package, hotelier packages, service and repair package. A token app can manage reservations, while esketitOS takes payments. All of it tightly integrated and a complete solution.</p>

<p>We aim to be compatible with the major cryptocurrencies.</p>

<p><b><u>Payment Technology</u></b></p>

<p>Forget scanning, cards and lines. Vicinity payments allows for a trusted list of clients to send a payment request to phone or compatible device and have it automatically accepted. This means when you buy a coffee at your fav coffee shop, a request is sent to your phone and the payment is made with no action required from the buyer. The buyer has manually included the coffee shop as a trusted user. This means the customer does not need to line up, just be in bluetooth or wifi vicinty to receive the request and make the payment. The seller manually creates enters the info out of pre-selected list and sends it to the user that shows up on the buyers terminal. We call this vicinity pay. We are working on how installation of esketitOS on both the buyer and sellers device can speak to eachother to perform this type of payment.</p> 


<p><b><u>Enterprise Wallet Design</u></b></p>

<p>You assign wallets to people and to departments. The first wallet is root, it should not be used, so the first wallet after root is the main wallet or the purse holder. Each user sees only their own wallets, only the root user can see everyone's wallet and perform administration on wallets. After the purse string holder, you may want to assign each employee that serves customers a wallet, their performance can be determined by the statistics on their wallet. When an employee comes to work, they log in and receive payments in their assigned wallet, the wallet is a workstation wallet and is a receive-only wallet. Wallets are programmable, so when end of shift is detected, funds are transferred to the main wallet. Payroll department can be assigned with a wallet with a limit and that deposit occurs for instance, 9am each Thursday. When payroll pay employees, they do so from the payroll wallet. There is no limit to amounts of wallets that can be generated and for any reason and for any design. All information and reporting arises out of the wallet performances, which are all held in blockchain. Programming the wallet is predefined, just like scheduled payments or recurring payments. A selection of predetermined actions are chosen from a list such as send at time or day, week or month or receive at time of day, week, month. The ability of the wallets are predetermined based on can send, can receive, can send and receive, can neither send nor receive. Other parameters such as gaining performance metrics of your employees or departments are not yet implemented.</p>

<p>This goes some way toward automated, artificial intelligent enterprise management. Many operations are being operated by computers such as flight control towers and so on. Automated enterprise management allows for expert managed large corporations.</p>

<p><b><u>Personal and Family Wallet design</u></b></p>

<p>The first wallet is root, it should not be used, so the first wallet after root is the main wallet. You assign your income to various wallets by creating a new wallet and naming it for the task specificed. For instance you want have an end of year holiday wallet, and you assign another wallet to send an x amount of coins each week. You may have family allowance and have assigned a wallet for that task. A family member may log into your computer with their own creditals and only see their own wallet or you may schedule the send funds to their own installation of terminal OS on their own computer. As Terminal OS is networked, the funds can be send anywhere in world, so if child is in troubles or in college and requires alloance, such an arrangement an be automated.</p>

<p>You are the main wallet user, design the financial network based on create a new wallet and assigning that wallet a reason and a role and a program. Their are no barriers the internet and therefore the Esketit network is worldwide and incorperates all users.</p>



<p>Copyright &copy; 2009-2021 esketit.org</p>

<p>Esketit Core version v0.21.1, Esketit is a fork of 3rd generation cryptocurrency development projects that started with Bitcoin, we attempt to incorperate the best up to date feature in each and code them into one concise piece of software.</p>

<p>Esketit is open source, anyone can contribute and please contribute if you find Esketit useful. Visit https://esketit.org/ for further information about the software.
The source code is available from https://github.com/esktit/. Esketit coin development is done through github.com.</p>

<p>This is experimental software. Distributed under the MIT software license, see the accompanying file COPYING or https://opensource.org/licenses/MIT</p>

<p>esketit.org is a software company, focussed on the software that is used with cryptocurrencies. Cryptocurrencies are software that run on computers over a network. All software is tightly integrated to utilize esketit coin.</p>

<p>The products are...</p>

1. Esketit Core<br />
2. Terminal OS<br />

<p>These are downloaded in one package and installed, then you run Terminal OS to use the coin</p>

<p>We implement many of the core concepts of computing, such as multi-user system, networking system, multi-tasking into a software for our cryptocurrency called Terminal OS. All high level development is done under the product named Terminal OS. The low level development is called Esketit Core.</p>

<p>For us the coin is a means of the software and the software development is central. We hope to being many of the facilities found in online banking and payment processors to a user-friendly interface. An interface that surpasses anything currently out there.</p>

<p>The core concept of Terminal OS is enterprise design through wallets. Just like a database design or a fowchart diagram. Assigning wallets to departments, employees, customers and programming those walets to automate process in the enterprise.</p>

<p>Think of Terminal OS as the general online bank facility that you log into and do your banking with all the features you would expect from an online bank while think of wallets as your bank accounts. The wallet however is encrypted with its very own passphrase, terminal OS abstracts this step and links it to your account and opens the wallet automatically when you login, so that you are not always entering different passphrases. Terminal OS also enforces user permissions on a wallet so a user can login but be restricted to a daily limit, this is for children access or for payroll department access.

<p><b>About</b></p>

Bitcoin Core version v0.21.1
Usage:  bitcoin-qt [command-line options]

Options:


-?
Print this help message and exit
-alertnotify=<cmd>
Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)
-assumevalid=<hex>
If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: 0000000000000000000b9d2ec5a352ecba0592946514a92f14319dc2b367fc72, testnet: 000000000000006433d1efec504c53ca332b64963c425395515b01977bd7b3b0, signet: 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)
-blockfilterindex=<type>
Maintain an index of compact filters by block (default: 0, values: basic). If <type> is not supplied or if <type> = 1, indexes for all known types are enabled.
-blocknotify=<cmd>
Execute command when the best block changes (%s in cmd is replaced by block hash)
-blockreconstructionextratxn=<n>
Extra transactions to keep in memory for compact block reconstructions (default: 100)
-blocksdir=<dir>
Specify directory to hold blocks subdirectory for *.dat files (default: <datadir>)
-blocksonly
Whether to reject transactions from network peers. Automatic broadcast and rebroadcast of any transactions from inbound peers is disabled, unless the peer has the 'forcerelay' permission. RPC transactions are not affected. (default: 0)
-conf=<file>
Specify path to read-only configuration file. Relative paths will be prefixed by datadir location. (default: bitcoin.conf)
-daemon
Run in the background as a daemon and accept commands
-datadir=<dir>
Specify data directory
-dbcache=<n>
Maximum database cache size <n> MiB (4 to 16384, default: 450). In addition, unused mempool memory is shared for this cache (see -maxmempool).
-debuglogfile=<file>
Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (-nodebuglogfile to disable; default: debug.log)
-includeconf=<file>
Specify additional configuration file, relative to the -datadir path (only useable from configuration file, not command line)
-loadblock=<file>
Imports blocks from external file on startup
-maxmempool=<n>
Keep the transaction memory pool below <n> megabytes (default: 300)
-maxorphantx=<n>
Keep at most <n> unconnectable transactions in memory (default: 100)
-mempoolexpiry=<n>
Do not keep transactions in the mempool longer than <n> hours (default: 336)
-par=<n>
Set the number of script verification threads (-4 to 15, 0 = auto, <0 = leave that many cores free, default: 0)
-persistmempool
Whether to save the mempool on shutdown and load on restart (default: 1)
-pid=<file>
Specify pid file. Relative paths will be prefixed by a net-specific datadir location. (default: bitcoind.pid)
-prune=<n>
Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. Warning: Reverting this setting requires re-downloading the entire blockchain. (default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >=550 = automatically prune block files to stay under the specified target size in MiB)
-reindex
Rebuild chain state and block index from the blk*.dat files on disk
-reindex-chainstate
Rebuild chain state from the currently indexed blocks. When in pruning mode or if blocks on disk might be corrupted, use full -reindex instead.
-settings=<file>
Specify path to dynamic settings data file. Can be disabled with -nosettings. File is written at runtime and not meant to be edited by users (use bitcoin.conf instead for custom settings). Relative paths will be prefixed by datadir location. (default: settings.json)
-startupnotify=<cmd>
Execute command on startup.
-sysperms
Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)
-txindex
Maintain a full transaction index, used by the getrawtransaction rpc call (default: 0)
-version
Print version and exit


Connection options:


-addnode=<ip>
Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.
-asmap=<file>
Specify asn mapping used for bucketing of the peers (default: ip_asn.map). Relative paths will be prefixed by the net-specific datadir location.
-bantime=<n>
Default duration (in seconds) of manually configured bans (default: 86400)
-bind=<addr>[:<port>][=onion]
Bind to given address and always listen on it (default: 0.0.0.0). Use [host]:port notation for IPv6. Append =onion to tag any incoming connections to that address and port as incoming Tor connections (default: 127.0.0.1:8334=onion, testnet: 127.0.0.1:18334=onion, signet: 127.0.0.1:38334=onion, regtest: 127.0.0.1:18445=onion)
-connect=<ip>
Connect only to the specified node; -noconnect disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.
-discover
Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)
-dns
Allow DNS lookups for -addnode, -seednode and -connect (default: 1)
-dnsseed
Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)
-externalip=<ip>
Specify your own public address
-forcednsseed
Always query for peer addresses via DNS lookup (default: 0)
-listen
Accept connections from outside (default: 1 if no -proxy or -connect)
-listenonion
Automatically create Tor onion service (default: 1)
-maxconnections=<n>
Maintain at most <n> connections to peers (default: 125)
-maxreceivebuffer=<n>
Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)
-maxsendbuffer=<n>
Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)
-maxtimeadjustment
Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: 4200 seconds)
-maxuploadtarget=<n>
Tries to keep outbound traffic under the given target (in MiB per 24h). Limit does not apply to peers with 'download' permission. 0 = no limit (default: 0)
-networkactive
Enable all P2P network activity (default: 1). Can be changed by the setnetworkactive RPC command
-onion=<ip:port>
Use separate SOCKS5 proxy to reach peers via Tor onion services, set -noonion to disable (default: -proxy)
-onlynet=<net>
Make outgoing connections only through network <net> (ipv4, ipv6 or onion). Incoming connections are not affected by this option. This option can be specified multiple times to allow multiple networks.
-peerblockfilters
Serve compact block filters to peers per BIP 157 (default: 0)
-peerbloomfilters
Support filtering of blocks and transaction with bloom filters (default: 0)
-permitbaremultisig
Relay non-P2SH multisig (default: 1)
-port=<port>
Listen for connections on <port>. Nodes not using the default ports (default: 8333, testnet: 18333, signet: 38333, regtest: 18444) are unlikely to get incoming connections.
-proxy=<ip:port>
Connect through SOCKS5 proxy, set -noproxy to disable (default: disabled)
-proxyrandomize
Randomize credentials for every proxy connection. This enables Tor stream isolation (default: 1)
-seednode=<ip>
Connect to a node to retrieve peer addresses, and disconnect. This option can be specified multiple times to connect to multiple nodes.
-timeout=<n>
Specify connection timeout in milliseconds (minimum: 1, default: 5000)
-torcontrol=<ip>:<port>
Tor control port to use if onion listening enabled (default: 127.0.0.1:9051)
-torpassword=<pass>
Tor control port password (default: empty)
-upnp
Use UPnP to map the listening port (default: 0)
-whitebind=<[permissions@]addr>
Bind to the given address and add permission flags to the peers connecting to it. Use [host]:port notation for IPv6. Allowed permissions: bloomfilter (allow requesting BIP37 filtered blocks and transactions), noban (do not ban for misbehavior; implies download), forcerelay (relay transactions that are already in the mempool; implies relay), relay (relay even in -blocksonly mode, and unlimited transaction announcements), mempool (allow requesting BIP35 mempool contents), download (allow getheaders during IBD, no disconnect after maxuploadtarget limit), addr (responses to GETADDR avoid hitting the cache and contain random records with the most up-to-date info). Specify multiple permissions separated by commas (default: download,noban,mempool,relay). Can be specified multiple times.
-whitelist=<[permissions@]IP address or network>
Add permission flags to the peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR-notated network (e.g. 1.2.3.0/24). Uses the same permissions as -whitebind. Can be specified multiple times.


Wallet options:


-addresstype
What type of addresses to use ("legacy", "p2sh-segwit", or "bech32", default: "bech32")
-avoidpartialspends
Group outputs by address, selecting all or none, instead of selecting on a per-output basis. Privacy is improved as an address is only used once (unless someone sends to it after spending from it), but may result in slightly higher fees as suboptimal coin selection may result due to the added limitation (default: 0 (always enabled for wallets with "avoid_reuse" enabled))
-changetype
What type of change to use ("legacy", "p2sh-segwit", or "bech32"). Default is same as -addresstype, except when -addresstype=p2sh-segwit a native segwit output is used when sending to a native segwit address)
-disablewallet
Do not load the wallet and disable wallet RPC calls
-discardfee=<amt>
The fee rate (in BTC/kB) that indicates your tolerance for discarding change by adding it to the fee (default: 0.0001). Note: An output is discarded if it is dust at this rate, but we will always discard up to the dust relay fee and a discard fee above that is limited by the fee estimate for the longest target
-fallbackfee=<amt>
A fee rate (in BTC/kB) that will be used when fee estimation has insufficient data. 0 to entirely disable the fallbackfee feature. (default: 0.00)
-keypool=<n>
Set key pool size to <n> (default: 1000). Warning: Smaller sizes may increase the risk of losing funds when restoring from an old backup, if none of the addresses in the original keypool have been used.
-maxapsfee=<n>
Spend up to this amount in additional (absolute) fees (in BTC) if it allows the use of partial spend avoidance (default: 0.00)
-mintxfee=<amt>
Fees (in BTC/kB) smaller than this are considered zero fee for transaction creation (default: 0.00001)
-paytxfee=<amt>
Fee (in BTC/kB) to add to transactions you send (default: 0.00)
-rescan
Rescan the block chain for missing wallet transactions on startup
-spendzeroconfchange
Spend unconfirmed change when sending transactions (default: 1)
-txconfirmtarget=<n>
If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: 6)
-wallet=<path>
Specify wallet path to load at startup. Can be used multiple times to load multiple wallets. Path is to a directory containing wallet data and log files. If the path is not absolute, it is interpreted relative to <walletdir>. This only loads existing wallets and does not create new ones. For backwards compatibility this also accepts names of existing top-level data files in <walletdir>.
-walletbroadcast
Make the wallet broadcast transactions (default: 1)
-walletdir=<dir>
Specify directory to hold wallets (default: <datadir>/wallets if it exists, otherwise <datadir>)
-walletnotify=<cmd>
Execute command when a wallet transaction changes. %s in cmd is replaced by TxID and %w is replaced by wallet name. %w is not currently implemented on windows. On systems where %w is supported, it should NOT be quoted because this would break shell escaping used to invoke the command.
-walletrbf
Send transactions with full-RBF opt-in enabled (RPC only, default: 0)


ZeroMQ notification options:


-zmqpubhashblock=<address>
Enable publish hash block in <address>
-zmqpubhashblockhwm=<n>
Set publish hash block outbound message high water mark (default: 1000)
-zmqpubhashtx=<address>
Enable publish hash transaction in <address>
-zmqpubhashtxhwm=<n>
Set publish hash transaction outbound message high water mark (default: 1000)
-zmqpubrawblock=<address>
Enable publish raw block in <address>
-zmqpubrawblockhwm=<n>
Set publish raw block outbound message high water mark (default: 1000)
-zmqpubrawtx=<address>
Enable publish raw transaction in <address>
-zmqpubrawtxhwm=<n>
Set publish raw transaction outbound message high water mark (default: 1000)
-zmqpubsequence=<address>
Enable publish hash block and tx sequence in <address>
-zmqpubsequencehwm=<n>
Set publish hash sequence message high water mark (default: 1000)


Debugging/Testing options:


-debug=<category>
Output debugging information (default: -nodebug, supplying <category> is optional). If <category> is not supplied or if <category> = 1, output all debugging information. <category> can be: net, tor, mempool, http, bench, zmq, walletdb, rpc, estimatefee, addrman, selectcoins, reindex, cmpctblock, rand, prune, proxy, mempoolrej, libevent, coindb, qt, leveldb, validation.
-debugexclude=<category>
Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except one or more specified categories.
-help-debug
Print help message with debugging options and exit
-logips
Include IP addresses in debug output (default: 0)
-logtimestamps
Prepend debug output with timestamp (default: 1)
-maxtxfee=<amt>
Maximum total fees (in BTC) to use in a single wallet transaction; setting this too low may abort large transactions (default: 0.10)
-printtoconsole
Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)
-shrinkdebugfile
Shrink debug.log file on client startup (default: 1 when no -debug)
-uacomment=<cmt>
Append comment to the user agent string


Chain selection options:


-chain=<chain>
Use the chain <chain> (default: main). Allowed values: main, test, signet, regtest
-signet
Use the signet chain. Equivalent to -chain=signet. Note that the network is defined by the -signetchallenge parameter
-signetchallenge
Blocks must satisfy the given script to be considered valid (only for signet networks; defaults to the global default signet test network challenge)
-signetseednode
Specify a seed node for the signet network, in the hostname[:port] format, e.g. sig.net:1234 (may be used multiple times to specify multiple seed nodes; defaults to the global default signet test network seed node(s))
-testnet
Use the test chain. Equivalent to -chain=test.


Node relay options:


-bytespersigop
Equivalent bytes per sigop in transactions for relay and mining (default: 20)
-datacarrier
Relay and mine data carrier transactions (default: 1)
-datacarriersize
Maximum size of data in data carrier transactions we relay and mine (default: 83)
-minrelaytxfee=<amt>
Fees (in BTC/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: 0.00001)
-whitelistforcerelay
Add 'forcerelay' permission to whitelisted inbound peers with default permissions. This will relay transactions even if the transactions were already in the mempool. (default: 0)
-whitelistrelay
Add 'relay' permission to whitelisted inbound peers with default permissions. This will accept relayed transactions even when not relaying transactions (default: 1)


Block creation options:


-blockmaxweight=<n>
Set maximum BIP141 block weight (default: 3996000)
-blockmintxfee=<amt>
Set lowest fee rate (in BTC/kB) for transactions to be included in block creation. (default: 0.00001)


RPC server options:


-rest
Accept public REST requests (default: 0)
-rpcallowip=<ip>
Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times
-rpcauth=<userpw>
Username and HMAC-SHA-256 hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcauth. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times
-rpcbind=<addr>[:port]
Bind to given address to listen for JSON-RPC connections. Do not expose the RPC server to untrusted networks such as the public internet! This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost)
-rpccookiefile=<loc>
Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)
-rpcpassword=<pw>
Password for JSON-RPC connections
-rpcport=<port>
Listen for JSON-RPC connections on <port> (default: 8332, testnet: 18332, signet: 38332, regtest: 18443)
-rpcserialversion
Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: 1)
-rpcthreads=<n>
Set the number of threads to service RPC calls (default: 4)
-rpcuser=<user>
Username for JSON-RPC connections
-rpcwhitelist=<whitelist>
Set a whitelist to filter incoming RPC calls for a specific user. The field <whitelist> comes in the format: <USERNAME>:<rpc 1>,<rpc 2>,...,<rpc n>. If multiple whitelists are set for a given user, they are set-intersected. See -rpcwhitelistdefault documentation for information on default whitelist behavior.
-rpcwhitelistdefault
Sets default behavior for rpc whitelisting. Unless rpcwhitelistdefault is set to 0, if any -rpcwhitelist is set, the rpc server acts as if all rpc users are subject to empty-unless-otherwise-specified whitelists. If rpcwhitelistdefault is set to 1 and no -rpcwhitelist is set, rpc server acts as if all rpc users are subject to empty whitelists.
-server
Accept command line and JSON-RPC commands


UI Options:


-choosedatadir
Choose data directory on startup (default: 0)
-lang=<lang>
Set language, for example "de_DE" (default: system locale)
-min
Start minimized
-resetguisettings
Reset all settings changed in the GUI
-splash
Show splash screen on startup (default: 1)

<p>Everyone has a wallet and a recieving address</p>

<p>You give people your address number and they can pay you, you get other peoples address number and you can pay them.</p>

<p>The funds go into the wallet.</p>

<p>You use that to send money. Its like a pin number for a key card.</p>

<p>One key is pubic</p>

<p>You send that to others so they can pay you. So you can receive money</p>

<p>They are displayed in their seperate sections in the interface. The send section displays your private keys, the receive section displays your public keys.</p>

<p>This is called a key pair</p>

<p>You can have as many key pairs as you like, each key pair is like one bank account. If you lose your key pair, your coins are lost.</p>

<p>All keys are Native SegWit (bech32) - https://www.ledger.com/academy/difference-between-segwit-and-native-segwit</p>

<p>Bech32 (address starts with "bc1"), bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq</p>


<p>If you want to buy or sell items with esketit, you need an esketit address.

			
<br />
			

			
			<p>Note, esketit OS is running off your computer. You are not communicating with another server. These are not accounts on another computer, the accounts you make are on your own computer.</p>
			
			<p>The blockchain is an accounting ledger but experimentation in developing a records ledger or information ledger, a product can accumulate a record of its past, from tracking numbers, delivery confirmation, from the assembly line to its repairs to the names of all its owners to the the last owner and so on.</p>
			
			<p>Notes: Emp_[1-4] wallets are programmed restricted to receive only, the wallet is also programmed to send the days taking to the main wallet at 5pm each day. The employee performance is monitored by wallet performance. The other set of Emp_[1-4] wallets are wages wallets, employees #1 to #4 are paid in their respective wallets. In their password protected accounts their appears two
wallets one for servicing customers the other for wages. Login times can be recorded as start and end of shift.</p>

			<p>Departments can also be allocated wallets. Dept [1-4] such as payroll department can recieve a allocation every Thursday to perform payroll and send wages to the empoyee wallets.</p>
			
			<p>Finally products, have their wallets to maintain records of the shipments and product, paper trail, whereabouts and relevant information that builds a profile on the enterprise. These are known as information wallets, or record wallets.</p>
			
			<p>Customers may have an account also, and therefore allocated wallets. Generally customers have their own install and interact with the enterprise as one party to another.</p>
			
			<p>Each user logs into the system and see what the root user has set up for them in their account, from anywhere in the world that has an Internet connection.</p>
			
			
			<h1>Enterprise Tests</h1>
			
			<p>enterpeises lose their standards over time, this where computers can audit the standards of your enterprise by conducting a series of tests.
			
			<p>Perform a series of tests on your enterpeise to ensure the operation is to a high standard.</p>
			
			<p>Test the telephone wait times and make mock calls to test the customer service</p>


<h3>Enterprise System vs. Personal Wallet</h3>

<p>Terminal OS is a multi-user operating system. Each user can have many wallets. Each new wallet can have some features enabled and disabled to endow the wallet with its purpose. For example a work wallet may be receive only with send automated to the root wallet at time of day each day. While a petty cash wallet may be sent a daily float each Thurday at 9am from the root wallet. A desciptive name of the wallet helps identify its purpose, along with the permissions you apply to them.</p>

<p>A typical enterprise setup,</p>

<ol>
  <li>Root wallet, all user wallets are programmed to send funds into this wallet.</li>
  <li>Workstation wallet, programmed to receive only and send its daily takings to the root wallet 5pm each day.</li>
  <li>Payroll Department wallet, is sent its float each Thursday at 9am.</li>
  <li>Eldest child the III, is sent allowance each day on condition it must be claimed from 6am to 7am.</li>
</ol>

This monetary system design of an enterprise or personal for efficient operation.

 around send access with 4 levels of access...

<ol>
<li>Root, with full permissions over the wallet, the only user that can create and delete wallets, know and set password on the wallets and send without limit. <b>The first user is root and creates one systems administrator.</b>
<li>Systems Administrator, no wallet access neither send nor receive, has access to user administration options. Can send public address to head office to be paid.</li>
<li>Group, cannot make new wallets, has send permissions conditioned by a daily limit, such as payroll dept. or children's allowance. Has facility to send address to head office to be paid.</li>
<li>Workstation, with only the ability to receive payments, no wallet creation and no send access. Has facility to send address to head office to be paid.</li>
</ol>

<p>Terminal OS is a network operating system. The type of user chosen, disables aspects of the interface, wallet creation feature and send form do not appear. A new user is given workstation access by default and a systems administrator has to manually login and bump up the user access afterwards as required.</p>

<p>If this is a one user system, then it is a personal wallet, you can group yourself to set your own limits to manage a budget. You use your personal wallet to generate an address to send to head office to be paid. In any case do not forget your username and password or your funds will be lost forever with no way to get them. <b>Write down your login details and store them in a safe place.</b></p>

<p>All wallets are encrypted with their own unique passphrase. All wallets are descriptor wallets.</p>

 <form>
  <label for="fname">Wallet name:</label><br>
  <input type="text" id="wallet_name" name="wallet_name"><br>
</form>

